---
title: "Tarea 2 Estad칤stica Actuarial II"

author:
  - "Maria Carolina Navarro Monge C05513"
  - "T치bata Picado Carmona C05961"
  - "Jose Pablo Trejos Conejo C07862"
  
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Se cargan las librer칤as necesarias
library(readxl)
library(dplyr)
library(ggplot2)
```


# Ejercicio 2

**Usando la metodolog칤a de Muestreo por Importancia, Si 洧녦\~洧녜(0.5,0.5) estime:**

## a. P(X\<-5)

Mediante el met칩do de integraci칩n por Montecarlo se obtiene el siguiente resultado:

```{r}
#----------------------------Ejercicio 2---------------------------------------

#---Estimaci칩n de funci칩n de distribuci칩n mediante Muestreo por Importancia----

set.seed(2901)
n <- 10^4 #tama침o de la muestra

X <- rnorm(n, 0.5, sqrt(0.5))

f <- dnorm(X, 0.5, sqrt(0.5))

valor_estimado_1 <- mean(f)

valor_real <- pnorm(-5, 0.5, sqrt(0.5))

comparaci칩n <- data.frame("Estimaci칩n" = valor_estimado_1, "Valor real" = valor_real)

print(comparaci칩n)
```

Como se puede observar, la estimaci칩n resultante converge lento al valor real. Por lo tanto, mediante Muestreo por Importancia se puede acelelar la convergencia empleando una densidad auxiliar. Para este caso, la densidad auxiliar a utilizar es una exponencial truncada de la forma $\lambda e^{-\lambda(x-t)}$, con x\>t.

La probabilidad a estimar es equivalente a P(X\>6). Nos basaremos en esta para aproximarla mediante el Muestro por Importancia por medio de una exponencial truncada en 6 con $\lambda = 1$. El procedimiento se muestra en el siguiente algoritmo:

```{r}
A <- rexp(n)+6 #datos aleatorios mayores a 6 con distribuci칩n exponencial

w <- dnorm(A, 0.5, sqrt(0.5)) / dexp(A-6)

valor_estimado <- mean(w)

resumen <- data.frame("Estimaci칩n" = valor_estimado, "Valor real" = valor_real)

print(resumen)

```

De tal manera, se obtiene una mejor aproximaci칩n de la probabilidad P(X\<-5), pues, es muy similar al valor real.

## b. Estime el error absoluto de la estimaci칩n del punto a.

El error absoluto de la estimaci칩n es:

```{r}
error_absoluto <- abs(valor_estimado-valor_real)
```

#Ejercicio 5

**Una aseguradora tiene un producto llamado Doble Seguro de Vida (DSV) el cual paga 2 veces la suma asegurada si la persona fallece antes de los 60 a침os, paga 1 suma asegurada cuando la persona cumple los 60 a침os (si no ha fallecido) y paga 1 suma asegurada si fallece despu칠s de los 60 a침os. Considerando:**

**a. Las tablas de vida din치micas de la SUPEN (<https://webapps.supen.fi.cr/tablasVida/Recursos/documentos/tavid2000-2150.xls>)**

**b. Un cliente de 30 a침os, hombre con una suma asegurable de 1 000 000 colones.**

**Construya con la ayuda de un MCMC la distribuci칩n de los pagos por a침o de que se espera de este seguro. Use al menos 10 000 iteraciones. Y muestre Histograma.**

La construcci칩n de la distribuci칩n de los pagos por a침o mediante MCMC se muestran en el siguiente c칩digo:

```{r}
#Se carga la base de datos
tabla_vida <- read_excel("tavid2000-2150.xls",
                         col_types = c("numeric", "numeric", "numeric", 
                         "numeric", "numeric", "numeric", "numeric"))

#Se filtra la base de datos para obtener los datos de un hombre nacido en 1994 
#con edades mayor o igual a 30

datos <- subset(tabla_vida, sex == 1 & ynac == 1994 & edad >=30, select = c(edad,qx, year))

#Se obtienen las probabilidades de sobrevivencia

px <- 1- datos$qx

#Se a침aden las probabilidades de sobrevivencia a la base datos
datos$px <- px

qx<- datos$qx
suma_asegurada_1 <- 10^6
suma_asegurada_2 <- 2*10^6

#--------------------MCMC---------------------------------|   

#Se simulan diversas trayectorias de vida de la persona
set.seed(2901)
iteraciones=10^4
n=length(px)
pago <- rep(0, 86)

for (i in 1:iteraciones) {
  U <- runif(n)  # Se toman como probabilidades de muerte
  t <- 1
  cont <- 1
  
  #Determinaci칩n del a침o de fallecimiento
  while (t == 1) {
    if (U[cont] < px[cont]) {
      cont <- cont + 1
    } else {
      t <- 0
    }
  }
  a침o_fallecimiento <- cont - 1
  
  #Asignar los pagos correspondientes al a침o de fallecimiento
  if (a침o_fallecimiento < 30) {
    pago[a침o_fallecimiento + 1] <- pago[a침o_fallecimiento + 1] + suma_asegurada_2 
  } else if (a침o_fallecimiento ==30) {
    pago[31] <- pago[31]+ suma_asegurada_1
  }else {
    pago[31] <- pago[31] + suma_asegurada_1 
    pago[a침o_fallecimiento + 1] <- pago[a침o_fallecimiento + 1] + suma_asegurada_1
  }
}

resultado <- data.frame("A침os pago"= datos$year, "Pago" = pago)

```

El histograma de los pagos esperados por a침o es el siguiente:

```{r}
ggplot(data = resultado, aes(x = A침os.pago, y = Pago)) +  
  geom_bar(stat = "identity", fill = "blue") +  
  labs(title = "Histograma de Pagos Esperados por a침o", x = "A침os", y = "Frecuencia")+
  theme_minimal()
```

Es evidente que la mayor cantidad de pagos se sit칰an a los 60 a침os y posteriomente 
despu칠s de los 60, lo que indica que es m치s probable que el cliente fallezca despu칠s de los 60 a침os.

Se puede verificar el resultado obtenido por MCMC si lo comparamos con un histograma 
obtenido mediante un m칠todo determinista como el que se muestra a continuaci칩n:

```{r}
#----- M칠todo determinista-----------------------------------------------------|

#se calculan los pagos esperados para cada a침o
pago_esperado <- c(0)
pago_esperado[1] <- suma_asegurada_2*qx[1]

#caso fallecimiento antes de los 60 a침os
for (i in 2: 29 ) {
    pago_esperado[i] <- suma_asegurada_2*n_p_30[i-1]*qx[i]
}

#caso sobrevive a los 60 a침os

pago_esperado[30] <-suma_asegurada_1*n_p_30[30]

#caso fallecimiento despu칠s de los 60 a침os

for (i in 1: (length(px)-30)) {
  pago_esperado[30+i] <- suma_asegurada_1*n_p_30[30+i-1]*qx[30+i]
}

resultado_determinista <- data.frame("A침os pago"= datos$year, "Pago" = pago_esperado)
 
ggplot(data = resultado_determinista, aes(x = A침os.pago, y = Pago)) +  
  geom_bar(stat = "identity", fill = "blue") +  
  labs(title = "Histograma de Pagos Esperados por a침o", x = "A침os", y = "Frecuencia")+
  theme_minimal()

```

Como se puede observar, los pagos esperados mediante el m칠todo determinista y el MCMC muestran distribuciones muy similares. Por tanto, se verifica que el resultado que se obtuvo por el m칠todo MCMC es aceptable.


```{r}
fnormal <- function(x,mu1,mu2,sigma1, sigma2) { 
  fx= exp(-((x-mu1)^2/(2*(sigma1)))) - exp(-((x-mu2)^2/(2*(sigma2)))) 
  return(fx) 
}

mu1 <- 4
mu2 <- 2
sigma1 <- 4
sigma2 <- 1

fZ <- function(x){return(fnormal(x,mu1,mu2,sigma1,sigma2))} 
```

```{r}
# Valores para el rango de la gr치fica
x_values <- seq(0, 16, length.out = 1000)

par(mfrow = c(1, 2))

# Gr치fico de la distribuci칩n de Z y las medias de X1 y X2
plot(x_values, fZ(x_values), type = "l", col = "blue", lwd = 2, 
     xlab = "Z", ylab = "Densidad", main = "Distribuci칩n de Z = X1 - X2")

# L칤neas verticales para las medias de X1 y X2
abline(v = c(mu1, mu2), col = c("red", "green"), lty = c(2, 2), lwd = 2)

# Etiquetas para las medias
text(mu1, 0.20, "Media X1", pos = 1, col = "red")
text(mu2, 0.10, "Media X2", pos = 1, col = "green")

# Gr치fico de la distribuci칩n en valor absoluto de Z y las medias de X1 y X2
plot(x_values, abs(fZ(x_values)), type = "l", col = "blue", lwd = 2, xlab = "Z", 
     ylab = "Densidad (Valor Absoluto)", main = "Distribuci칩n de Z = X1 - X2")

abline(v = c(mu1, mu2), col = c("red", "green"), lty = c(2, 2), lwd = 2)

text(mu1, 0.20, "Media X1", pos = 1, col = "red")
text(mu2, 0.10, "Media X2", pos = 1, col = "green")
```

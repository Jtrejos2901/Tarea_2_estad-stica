---
title: "Tarea 2 Estad√≠stica Actuarial II"

author:
  - "Maria Carolina Navarro Monge C05513"
  - "T√°bata Picado Carmona C05961"
  - "Jose Pablo Trejos Conejo C07862"
  
output:
  pdf_document:
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Primeramente, se cargan las librer√≠as necesarias.

```{r, message=FALSE}
library(tidyverse)
library(readxl)
```


# Ejercicio 2

**Usando la metodolog√≠a de Muestreo por Importancia, Si X\~N(0.5,0.5) estime:**

## a. P(X\<-5)

Primeramenre, mediante el met√≥do de integraci√≥n por Montecarlo se obtiene el siguiente resultado:

```{r, warning=FALSE}

#--Estimaci√≥n de funci√≥n de distribuci√≥n mediante integraci√≥n por Montecarlo--

set.seed(2901)
n <- 10^4 #tama√±o de la muestra

X <- rnorm(n, 0.5, sqrt(0.5))

f <- dnorm(X, 0.5, sqrt(0.5))

valor_estimado_1 <- mean(f)

valor_real <- pnorm(-5, 0.5, sqrt(0.5))

comparacion <- data.frame("Estimaci√≥n" = valor_estimado_1, "Valor real" = valor_real)

print(comparacion)
```

Como se puede observar, la estimaci√≥n resultante converge lento al valor real. Por lo tanto, mediante Muestreo por Importancia se puede acelelar la convergencia empleando una densidad auxiliar. Para este caso, la densidad auxiliar a utilizar es una exponencial truncada de la forma $\lambda e^{-\lambda(x-t)}$, con x\>t.

La probabilidad a estimar es equivalente a P(X\>6). Nos basaremos en esta para aproximarla mediante el Muestro por Importancia por medio de una exponencial truncada en 6 con $\lambda = 1$. El procedimiento se muestra en el siguiente algoritmo:

```{r, warning=FALSE}

#--Estimaci√≥n de funci√≥n de distribuci√≥n mediante Muestreo por Importancia--

A <- rexp(n)+6 #datos aleatorios mayores a 6 con distribuci√≥n exponencial

w <- dnorm(A, 0.5, sqrt(0.5)) / dexp(A-6)

valor_estimado <- mean(w)

resumen <- data.frame("Estimaci√≥n" = valor_estimado, "Valor real" = valor_real)

print(resumen)
```

De tal manera, se obtiene una mejor aproximaci√≥n de la probabilidad P(X\<-5), pues, es muy similar al valor real.

## b. Estime el error absoluto de la estimaci√≥n del punto a.

El error absoluto de la estimaci√≥n es:

```{r, warning=FALSE}
error_absoluto <- abs(valor_estimado-valor_real)
```

# Ejercicio 4

**Sea $f(x) = sen\left(x + \frac{cos(10x)}{3}\right)$ para $x\in[-2,2]$**
## a.Utilizando el algoritmo de recalentamiento simulado estime el m√≠nimo global en [‚àí2,2], con valor inicial en 1.5.

Primero definimos la funci√≥n en R y la graficamos para darnos una idea de d√≥nde puede estar ubicado el m√≠nimo global de la funci√≥n en el intervalo. 

```{r}
fx <- function(x){sin(x + (cos(10*x)/3))} 
curve(fx,col="violet",lwd=2,from=-2,to = 2,n=1000,ylab="f(x)")
title("Gr√°fico de la funci√≥n")
```

Ahora definimos la funci√≥n que va a ejecutar el algoritmo de recalentamiento simulado la cual va a recibir la funci√≥n definida anteriormente, el alpha que en este caso se establece en 0.1, el valor inicial en 1.5, n√∫mero de iteraciones que para este ejercicio es de 1000 y por √∫ltimo, el m√≠nimo y m√°ximo del intervalo observado -2 y 2 respectivamente. 

```{r}
recalentamiento_simulado <- function(f,alpha=0.5,s0=0,niter,mini=-Inf,maxi=Inf){ 
  s_n <- s0 
  estados <- rep(0,niter) 
  iter_count <- 0 
  
  for(k in 1:niter){ 
    estados[k]<-s_n 
    T <- (1-alpha)^k
    s_new <- rnorm(1,s_n,1)
    
    if(s_new<mini){
      s_new <- mini
    } 
    
    if(s_new>maxi){
      s_new <- maxi
    } 
    
    dif <- f(s_new)-f(s_n)
    
    if(dif< 0){ 
      s_n <- s_new 
    } else { 
        random <- runif(1,0,1) 
        
        if(random <exp(-dif/T)){ 
          s_n <- s_new 
        } 
        
    } 
    
    iter_count <- iter_count +1
    
  }
  
  return(list(r=s_n,e=estados)) 
}

Resultado <- recalentamiento_simulado(fx,0.1,1.5,1000,-2,2) 
Resultado$r
```

Una vez ejecutado el c√≥digo arroja que el m√≠nimo global de la funci√≥n es -1.805683, para corrobar este resultado se decide graficar de nuevo la funci√≥n junto con el m√≠nimo. 

```{r}
curve(fx,col="#FFB6C1",lwd=2,from=-2,to = 2,n=1000,ylab="f(x)")
title("Gr√°fico y m√≠nimo global de la funci√≥n")
abline(v=Resultado$r,col="#98FB98")
text(Resultado$r, 0, "M√≠nimo", pos = 1, col = "#98FB98")
```

## b.Grafique el resultado de los estados donde estuvo la cadena de la estimaci√≥n del punto a.**

```{r}
plot(Resultado$e, xlab = "Iteraciones", ylab = "Valor (x)", 
     main = "Estados de la cadena")
```

# Ejercicio 5

**Una aseguradora tiene un producto llamado Doble Seguro de Vida (DSV) el cual paga 2 veces la suma asegurada si la persona fallece antes de los 60 a√±os, paga 1 suma asegurada cuando la persona cumple los 60 a√±os (si no ha fallecido) y paga 1 suma asegurada si fallece despu√©s de los 60 a√±os. Considerando:**

**a. Las tablas de vida din√°micas de la SUPEN (<https://webapps.supen.fi.cr/tablasVida/Recursos/documentos/tavid2000-2150.xls>)**

**b. Un cliente de 30 a√±os, hombre con una suma asegurable de 1 000 000 colones.**

**Construya con la ayuda de un MCMC la distribuci√≥n de los pagos por a√±o de que se espera de este seguro. Use al menos 10 000 iteraciones. Y muestre Histograma.**

Primeramente, se carga la tabla de vida din√°mica de la SUPEN y se filtra para 
obtener los datos correspondientes para un hombre que en el presente a√±o (2024)
tiene 30 a√±os

```{r, warning=FALSE}
#Se carga la base de datos
tabla_vida <- read_excel("tavid2000-2150.xls",
                         col_types = "numeric")

#Se filtra la base de datos para obtener los datos de un hombre nacido en 1994 
#con edades mayor o igual a 30

datos <- subset(tabla_vida, sex == 1 & ynac == 1994 & edad >=30, select = c(edad,qx, year))

```

Adem√°s, se calculan las probabilidades de sobrevivencia necesarias para procesos
posteriores

```{r, warning=FALSE}
#Se obtienen las probabilidades de sobrevivencia

px <- 1- datos$qx

#Se a√±aden las probabilidades de sobrevivencia a la base datos
datos$px <- px
```

La construcci√≥n de la distribuci√≥n de los pagos por a√±o mediante MCMC se muestran en el siguiente c√≥digo:

```{r, warning=FALSE}

suma_asegurada_1 <- 10^6
suma_asegurada_2 <- 2*10^6

#--------------------MCMC---------------------------------|   

#Se simulan diversas trayectorias de vida de la persona
set.seed(2901)
iteraciones=10^4
n=length(px)
pago <- rep(0, 86)

for (i in 1:iteraciones) {
  U <- runif(n)  # Se toman como probabilidades de muerte
  t <- 1
  cont <- 1
  
  #Determinaci√≥n del a√±o de fallecimiento
  while (t == 1) {
    if (U[cont] < px[cont]) {
      cont <- cont + 1
    } else {
      t <- 0
    }
  }
  a√±o_fallecimiento <- cont - 1
  
  #Asignar los pagos correspondientes al a√±o de fallecimiento
  if (a√±o_fallecimiento < 30) {
    pago[a√±o_fallecimiento + 1] <- pago[a√±o_fallecimiento + 1] + suma_asegurada_2 
  } else if (a√±o_fallecimiento ==30) {
    pago[31] <- pago[31]+ suma_asegurada_1
  }else {
    pago[31] <- pago[31] + suma_asegurada_1 
    pago[a√±o_fallecimiento + 1] <- pago[a√±o_fallecimiento + 1] + suma_asegurada_1
  }
}

resultado <- data.frame("A√±os pago"= datos$year, "Pago" = pago)

```

El histograma de los pagos esperados por a√±o es el siguiente:

```{r, warning=FALSE}
ggplot(data = resultado, aes(x = A√±os.pago, y = Pago)) +  
  geom_bar(stat = "identity", fill = "blue") +  
  labs(title = "Histograma de Pagos Esperados por a√±o", x = "A√±os", y = "Frecuencia")+
  theme_minimal()
```

Es evidente que la mayor cantidad de pagos se sit√∫an a los 60 a√±os y posteriomente 
despu√©s de los 60, lo que indica que es m√°s probable que el cliente fallezca despu√©s de los 60 a√±os.

Se puede verificar el resultado obtenido por MCMC si lo comparamos con un histograma 
obtenido mediante un m√©todo determinista como el que se muestra a continuaci√≥n:

```{r, warning=FALSE}
#----- M√©todo determinista-----------------------------------------------------|

qx<- datos$qx

#Se crea una funci√≥n que obtiene n_p_30 (probabilidad de sobrevivencia acumulada)
n_p_30 <- c(0)

n_p_30_function <- function(px) {

  for (i in 1:length(px)) {
    resultado <-1
    for(j in 1: i){
      resultado <- resultado*px[j]
    }
    
    n_p_30[i] <- resultado
  }
  
  return(n_p_30)
}

n_p_30 <- n_p_30_function(px)

datos$n_p_30 <- n_p_30 


#se calculan los pagos esperados para cada a√±o
pago_esperado <- c(0)
pago_esperado[1] <- suma_asegurada_2*qx[1]

#caso fallecimiento antes de los 60 a√±os
for (i in 2: 29 ) {
    pago_esperado[i] <- suma_asegurada_2*n_p_30[i-1]*qx[i]
}

#caso sobrevive a los 60 a√±os

pago_esperado[30] <-suma_asegurada_1*n_p_30[30]

#caso fallecimiento despu√©s de los 60 a√±os

for (i in 1: (length(px)-30)) {
  pago_esperado[30+i] <- suma_asegurada_1*n_p_30[30+i-1]*qx[30+i]
}

resultado_determinista <- data.frame("A√±os pago"= datos$year, "Pago" = pago_esperado)
 
ggplot(data = resultado_determinista, aes(x = A√±os.pago, y = Pago)) +  
  geom_bar(stat = "identity", fill = "blue") +  
  labs(title = "Histograma de Pagos Esperados por a√±o", x = "A√±os", y = "Frecuencia")+
  theme_minimal()

```

Como se puede observar, los pagos esperados mediante el m√©todo determinista y el MCMC muestran distribuciones muy similares. Por tanto, se verifica que el resultado que se obtuvo por el m√©todo MCMC es aceptable.

# Ejercicio 6

**Usando el Algoritmo de Metropolis-Hastings construya una muestra de $ùëç=ùëã1‚àíùëã2$ donde $ùëã1~ùëÅ(ùúá,ùúé^2)$ y $ùëã2~ùëÅ(ùúá/2,ùúé^2/4)$, considere para este ejercicio $ùúá=ùúé^2=4$.**

## a.Gr√°fique la distribuci√≥n de Z junto con las medias de X1,X2.

Primero se realiza la funci√≥n de Z. Para ello se hace la resta de los n√∫cleos de las distribuciones de X1 y X2.  
```{r}
fnormal <- function(x,mu1,mu2,sigma1, sigma2) { 
  fx <- exp(-((x-mu1)^2/(2*(sigma1)))) - exp(-((x-mu2)^2/(2*(sigma2)))) 
  return(fx) 
}

mu1 <- 4
mu2 <- 2
sigma1 <- 4
sigma2 <- 1

fZ <- function(x){return(fnormal(x,mu1,mu2,sigma1,sigma2))}
```

Ahora se realiza el gr√°fico de la distribuci√≥n de Z. 

```{r}
# Valores para el rango de la gr√°fica
x_values <- seq(0, 16, length.out = 1000)

par(mfrow = c(1, 2))

# Gr√°fico de la distribuci√≥n de Z y las medias de X1 y X2
plot(x_values, fZ(x_values), type = "l", col = "#ADD8E6", lwd = 2, 
     xlab = "Z", ylab = "Densidad", main = "Distribuci√≥n de Z = X1 - X2")

# L√≠neas verticales para las medias de X1 y X2
abline(v = c(mu1, mu2), col = c("#FFB6C1", "#98FB98"), lty = c(2, 2), lwd = 2)

# Etiquetas para las medias
text(mu1, 0.20, "Media X1", pos = 1, col = "#FFB6C1", cex = 0.75)
text(mu2, 0.10, "Media X2", pos = 1, col = "#98FB98", cex = 0.75)

# Gr√°fico de la distribuci√≥n en valor absoluto de Z y las medias de X1 y X2
plot(x_values, abs(fZ(x_values)), type = "l", col = "#ADD8E6", lwd = 2, xlab = "Z", 
     ylab = "Densidad (Valor Absoluto)", main = "Distribuci√≥n de Z = X1 - X2")

abline(v = c(mu1, mu2), col = c("#FFB6C1", "#98FB98"), lty = c(2, 2), lwd = 2)

text(mu1, 0.20, "Media X1", pos = 1, col = "#FFB6C1", cex = 0.75)
text(mu2, 0.10, "Media X2", pos = 1, col = "#98FB98", cex = 0.75)
```

## b.Gr√°fique la distribuci√≥n (histograma) de la muestra MCMC del algoritmo junto con las medias de X1,X2

Antes de graficar el histograma se debe crear y ejecutar la funci√≥n encargada del algoritmo MCMC. 

```{r}
fpK <- function(x,y){ 
  pK <- dcauchy(y,location = x) #x es elcentro del pico de la distribuci√≥n. 
  return(pK) 
} 

N <- 10^5 #N√∫mero de Iteraciones 
L <- 1000 #periodo quemado (burnin) 
MCMC <- matrix(data=0,nrow=N,ncol=12) 
colnames(MCMC) <- c("x","y","PIx","PIy","Kxy","Kyx","Rxy","Ryx","Mxy","Myx","Fxy",
                  "Salto") 
#1.Iniciar con un valor arbitrario de x del dominio de distribuci√≥n 
x <- runif(1,-50,50)
for(i in 1:N){ 
  #2.Generamos la propuesta con una distribucion arbitraria 
  y <- rcauchy(1,location=x) #Valor aleatorio seg√∫n X 
  
  #3.Tasa de Aceptaci√≥n 
  PIx <- fZ(x) 
  PIy <- fZ(y) 
  Kxy <- fpK(x,y) 
  Kyx <- fpK(y,x) 
  Rxy <- (PIy*Kyx) / (PIx*Kxy) 
  Ryx <- (PIx*Kxy) / (PIy*Kyx) 
  
  #Matriz estoc√°stica de los estados de la distribuci√≥n estacionaria 
  if(x!=y){ 
    Mxy <- Kxy*min(1,Rxy) 
    Myx <- Kyx*min(1,Ryx) 
  } else {
    Mxy <- -1 
    Myx <- -1 
  } 
  
  #4.Criterio de Aceptacion o Rechazo 
  #Probabilidad de aceptaci√≥n, runif(1) 
  Fxy <- runif(1) 
  MCMC[i,] <- c(x,y,PIx,PIy,Kxy,Kyx,Rxy,Ryx,Mxy,Myx,Fxy,0) 
  
  if(Fxy < Rxy) { 
    x <- y 
    lsalto <- 1 
  } else {
    lsalto <- 0 
  }
  
  MCMC[i,12]  <- lsalto
  
} 

mcmc <- MCMC[(L+1):N,"x"]
```

```{r}
hist(mcmc, freq=FALSE, main="Distribuci√≥n de muestra MCMC", xlab="x", 
     ylab="distribucion(x)", breaks=200) 
abline(v=mu1,col="#FFB6C1",lwd=3) 
abline(v=mu2,col="#98FB98",lwd=3)
```

```{r}
hist(abs(mcmc), freq = FALSE, 
     main = "Distribuci√≥n de muestra MCMC (Valor Absoluto)", 
     xlab = "x", ylab = "distribucion(x)", breaks = 200)
abline(v=mu1,col="#FFB6C1",lwd=3) 
abline(v=mu2,col="#98FB98",lwd=3)
```


## c.Estime la media de la distribuci√≥n resultante de Z.

La media resultante de Z es de 5.064882 
```{r}
media <- mean(mcmc)
media
```

## d.Gr√°fique el Traceplot de muestra MCMC del algoritmo junto con las medias de X1,X2,Z.

```{r}
options(scipen = 999)
par(mfrow = c(1, 1))

plot(mcmc,type="l",xlab="x",ylab ="y",main="Traceplot de muestra MCMC")
abline(h=mu1,col="#FFB6C1",lwd=3) 
abline(h=mu2,col="#98FB98",lwd=3) 
abline(h=media,col="#FFA07A",lwd=3)
```

## e.El gr√°fico de Autocorrelaci√≥n de la muestra MCMC del algoritmo.

```{r}
acf(mcmc,main="Autocorrelaci√≥n de muestra MCMC")
```

## f.El gr√°fico de la convergencia de la media de la muestra MCMC del algoritmo.

```{r}
m <- N-L 
acumulado <- cumsum(mcmc)/(1:m) 
plot(1:m,acumulado,col="#ADD8E6",type="l",ylab="promedio",xlab="Iteraciones", 
     main="Convergencia de la media de la muestra MCMC")
```

## g.La tasa de aceptaci√≥n del algoritmo.
La tasa de aceptaci√≥n es de un 60.097$\%$
```{r}
cat("Tasa de aceptaci√≥n:", mean(MCMC[,"Salto"]),"\n")
```

Tambi√©n este ejercicio se puede replantear como que Z al ser uan resta de normales tambi√©n es una normal con media $\mu_1 - \mu_2$ y varianza $\sigma_1 + \sigma_2$. Por lo tanto, se puede ejcutar el c√≥digo anterior pero definiendo la funci√≥n a muestrar como una normal con los par√°metros indicados. 

```{r, eval=FALSE}
fnormal <- function(x,mu1,mu2,sigma1, sigma2) { 
  fx <- dnorm(x, mean = mu1-mu2, sd = sigma1+sigma2)
  return(fx) 
}

mu1 <- 4
mu2 <- 2
sigma1 <- 4
sigma2 <- 1

fZ <- function(x){return(fnormal(x,mu1,mu2,sigma1,sigma2))} 
```
